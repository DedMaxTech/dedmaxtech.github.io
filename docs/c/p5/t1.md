import PdfViewer from '@site/src/components/PdfViewer';
import pdf from './pdf/task5_1.pdf'


# Задача 1

<PdfViewer file={pdf}/>

Сначала базовый ввод вывод:

```c
int main() {
    int N; 
    double x; // используем double тк по условию понадобится точность 10^-15
    scanf("%d", &N);
    for (int i = 0; i < N; ++i){
        scanf("%lf", &x); // считваем в буфер число
        printf("%.15g\n", exp(x)); // вызываем функцию экспоненты и сразу выводим ответ
        //      ^^^^^ выводим как нас попросили по условию для точности, а именно:
        // .15 значит до 15 знаков после запятой и g - выводит число как обычный %f если помещается, 
        // а если нет, то в экспоненциальном виде %e (1.3456e+56)
    }
    return 0;
}
```

Осталось по мелочи реализовать `exp(x)`:

```c    
double exp(double x) {
    // highlight-next-line
    if (x < 0) return 1.0 / exp(-x);
    ...
}
```

Во первых, помним что $x^{-n} = \dfrac{1}{x^n}$, так что как только видим отрицательное число просто делим `1` на эту же функцию, но уже с положительным `x` (минус на минус = плюс) и не паримся с отрицательным иксом.


Итак... Что за ряды Тейлора и как нам при помощи этого считать экспоненту. [По википедии](https://ru.wikipedia.org/wiki/Ряд_Тейлора), это разложение функции в бесконечную сумму степенных функций, про это всё вам расскажут/уже рассказали на мат анализе. Но суть в том что для решения задачи нам нужно релизовать подсчёт экспоненты через этот ряд Маклорена: 

$$
\mathrm{e}^{x} = 1 + \dfrac{x}{1!} + \dfrac{x^2}{2!} + \dfrac{x^3}{3!} + \cdots + \dfrac{x^n}{n!}
$$

Считать до бесконечности мы пока не будем: по условию у нас дана точность , следовательно считать будем то тех пор пока элемент последовательности больше $10^{-15}$ (ведь элементы меньше не будут вносить эффект для желаемой точности)

Интуитивно, мы просто в цикле мы будем вычислять элементы последовательности и суммировать их, для вычисления нам надо посчитать степень `x` и факториал, **но такой подход является не очень эффективным**. 

Заметим, что нам необязательно снуля считать весь элемент, а **достаточно предыдущий домжнодить на `x` и разделить на `n`**. _К примеру:_ `x=5`,`n=3`, $arr_3 =  \dfrac{x^n}{n!} = \dfrac{5*5*5}{1*2*3}$. Мы хотим посчитать следующий элемент с `n=4`, и вместо того чтобы считать всё заного мы домнажаем $arr_4 = arr_3 * x / n = \dfrac{5*5*5*5}{1*2*3*4}$. Теперь нам нужно просто реализовать это в коде, причём весьма просто

```c
double exp(double x) {
    if (x < 0) return 1 / exp(-x);
    
    int n = 1;  // номер текущего элемента
    double sum=1, term=1; // сумма элементов, последний элемент последовательности
    // мы сразу добавляем первый элемент 1 (см формулу), поэтому сумма 1 и последний элемент 1

    // highlight-start
    while (term > 1e-15) { // пока (последний элемент влияет на точность)
        term = term * x / n++;  // чтобы считать следующий элемент домнажаем текущий на x и делим на n
        //                ^^^ в той же строке увеличиваем n (постфиксно, сначение используется старое)
        sum += term; // добавляем элемент к общей сумме
    }
    // highlight-end
    return sum; // возвращаем сумму
}
```

И плов готов!

Полный код:

```c showLineNumbers
#include <stdio.h>

double exp(double x) {
    if (x < 0) return 1 / exp(-x);
    
    double sum = 1,term = 1;
    int n = 1;  
    while (term > 1e-15) {
        term = term * x / n++;  
        sum += term;
    }
    return sum;
}

int main(void){
    int N;      
    double x;
    scanf("%d", &N);
    for (int i = 0; i < N; ++i){
        scanf("%lf", &x);
        printf("%.15g\n", exp(x));
    }
    return 0;
}
```

